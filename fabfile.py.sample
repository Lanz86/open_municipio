## -*- mode: python -*-
"""
Starter fabfile for deploying a Django-powered web application.

All the settings marked with ``CHANGEME`` MUST be changed to reflect
project-specific setup.  Other settings MAY be changed, but their value should be
generic enough to provide for sensible defaults.

"""

import os

from fabric.api import *
from fabric.contrib.project import rsync_project
from fabric.contrib import files, console
from fabric import utils
from fabric.context_managers import cd, lcd, settings, hide

# Python interpreter executable to use on virtualenv creation
PYTHON_BIN = "python2.6"  ## CHANGEME!
PYTHON_PREFIX = "" # e.g. ``/usr``, ``/usr/local``; leave empty for default
PYTHON_FULL_PATH = "%s/bin/%s" % (PYTHON_PREFIX, PYTHON_BIN) if PYTHON_PREFIX else PYTHON_BIN

# exclude patterns for ``rsync`` invocations
RSYNC_EXCLUDE = ( ##CHANGEME!
    '.git',
    '*.pyc',
    '*.example',
    '*.db',
    'media/admin',
    'media/attachments',
    'local_settings.py',
    'fabfile.py',
    'bootstrap.py',
)

## TODO: these constants should be read from an external configuration file
# the name of the project managed by this fabfile
env.project = 'myproject' ##CHANGEME!
# a unique identifier for this web application instance
# usually is set to the primary domain from which the web application is accessed
env.app_domain = 'www.example.com' ##CHANGEME!

## Environment-specific setup
def staging():
    """ Use staging environment on remote host"""
    env.environment == 'staging'
    ## TODO: these constants should be read from an external configuration file
    # the system user (on the server machine) used for website management
    env.web_user = 'webuser' ##CHANGEME!
    # the parent directory of domain-specific directories (on the server machine) 
    env.web_root = os.path.join('/home', env.web_user, 'websites') 
    # the root directory for domain-specific files (on the server machine)
    env.domain_root = os.path.join(env.web_root, env.app_domain) 
    # the root directory of application-specific Python virtual environment (on the server machine)
    env.virtualenv_root = os.path.join(env.domain_root, 'private', 'venv') 
    # the root directory for project-specific files (on the server machine)
    env.project_root = os.path.join(env.domain_root, 'private', env.project) 
    # the root directory for application-specific Python code (on the server machine)
    env.code_root = os.path.join(env.project_root, env.project) ##CHANGEME!
    # import path of Django settings file for the staging environment
    env.settings = '%(project)s.settings_staging' % env 
    # Directory where static files should be collected.  This MUST equal the value
    # of ``STATIC_ROOT`` attribute of Django settings module used on the server.
    env.static_root =  os.path.join(env.domain_root, 'public', 'static') ## CHANGEME!


def production():
    """ Use production environment on remote host"""
    env.environment = 'production'
    utils.abort('Production deployment not yet implemented.')


## Webserver management

def webserver_reload():    
    """Reload the webserver on remote host"""
    run('/etc/init.d/apache2 reload')


def webserver_restart():    
    """Restart the webserver on remote host"""
    run('/etc/init.d/apache2 restart')


def webserver_enable_site(site_name):
    """Enable a webserver virtualhost"""
    run('a2ensite %s' % site_name)


def webserver_disable_site(site_name):
    """Disable a webserver virtualhost"""
    run('a2dissite %s' % site_name)


def upload_webserver_conf():
    """Upload webserver configuration to remote host """
    require('environment', provided_by=('staging', 'production'))
    source = os.path.join('apache', '%(environment)s.conf' % env)
    dest = os.path.join('/etc/apache2/sites-available', env.app_domain)
    put(source, dest, mode=0755)
  

def update_webserver_conf():
    """Update webserver configuration on remote host """
    upload_webserver_conf()
    webserver_enable_site(env.app_domain)
    webserver_restart()


def touch_WSGI_script():
    """ Touch WSGI file to trigger code reload """
    require('project_root', provided_by=('staging', 'production'))
    apache_dir = os.path.join(env.code_root, 'apache')
    with cd(apache_dir):
        run('touch django.wsgi')

## Virtual environment management

def create_virtualenv():
    """Create a virtualenv on remote host"""
    require('virtualenv_root', provided_by=('staging', 'production'))
    args = '--clear --distribute --python=%s' % PYTHON_FULL_PATH
    run('virtualenv %s %s' % (args, env.virtualenv_root))


def ensure_virtualenv():
    """Check if a project-specific virtualenv already exists; if not, create it."""
    require('virtualenv_root', provided_by=('staging', 'production'))
    if exists(env.virtualenv_root):
        return
    else:
        create_virtualenv()


def virtualenv(venv_root):
    """
    This context manager is intended for specifying a virtualenv to use.
    
    Note that it should be used only for selecting a virtualenv different from
    the project-specific one (available from ``env.virtualenv_root``)
    """
    return settings(virtualenv_root=venv_root)


def activate_virtualenv(venv_root=None):
    """Activate virtualenv on remote host"""
    if not venv_root:
        require('virtualenv_root', provided_by=('staging', 'production'))
    else:
        env.virtualenv_root = venv_root
    env.activation_script = os.path.join(env.virtualenv_root, 'bin/activate')
    run('source %(activation_script)s' % env) 


def run_venv(command, **kwargs):
    """
    Run a command (via ``fabric.api.run``) within a given virtualenv context 
    (to be specified either via ``env.virtualenv_root`` or the ``virtualenv`` 
    context manager)
    """
    activate_virtualenv()
    run(command, **kwargs)


def update_requirements():
    """Update external dependencies on remote host"""
    require('project_root', provided_by=('staging', 'production'))
    ensure_virtualenv()
    requirements = os.path.join(env.project_root, 'requirements')
    # TODO: generalize to multiple requirement files
    with cd(requirements):
        cmd = ['pip install']
        cmd += ['-E %(virtualenv_root)s' % env]
        cmd += ['--requirement %s' % os.path.join(requirements, 'apps.txt')]
        run(' '.join(cmd))

## Application code management

def update_code():
    """Transfer application code to remote host"""
    require('root', provided_by=('staging', 'production'))
    if env.environment == 'production':
        if not console.confirm('Are you sure you want to deploy production?',
                               default=False):
            utils.abort('Production deployment aborted.')
    # defaults rsync options:
    # -pthrvz
    # -p preserve permissions
    # -t preserve times
    # -h output numbers in a human-readable format
    # -r recurse into directories
    # -v increase verbosity
    # -z compress file data during the transfer
    extra_opts = '--omit-dir-times'
    rsync_project(
        env.project_root,
        exclude=RSYNC_EXCLUDE,
        delete=True,
        extra_opts=extra_opts,
    )
    # trigger code reloading
    touch_WSGI_script()

## Static files management

def setup_static_files():
    require(('static_root','virtualenv_root'), provided_by=('staging', 'production'))
    # safety checks
    assert env.static_root.strip() != '' and env.static_root.strip() != '/'
    # Before Django 1.4 we don't have the ``--clear`` option to ``collectstatic``
    run("rm -rf %(static_root)s/*" % env)

    run_venv('django-admin.py collectstatic -v 0 --noinput --settings=%(settings)' % env)


## Database management

def create_database():
    """Create the application's database on the server machine"""
    raise NotImplementedError


def drop_database():
    """Delete the application's database on the server machine"""
    raise NotImplementedError


def remote_sync_db():
    """Sync the application's database on the server machine"""
    require(('settings', 'virtualenv_root', provided_by=('staging', 'production'))
    run_venv('django-admin.py syncdb --settings=%(settings)' % env)
    

def update_database():
    """Update remote database (including South migrations, if any)."""
    if getattr(env, 'initial_deploy', False):
        run_venv('django-admin.py syncdb --all --noinput --settings=%(settings)' % env)
        run_venv('django-admin.py migrate --fake --noinput --settings=%(settings)' % env)
    else:
        run_venv('django-admin.py syncdb --all --noinput --settings=%(settings)' % env)
        run_venv('django-admin.py migrate --noinput --settings=%(settings)' % env)

## Macro-tasks

def initial_deploy():
    """
    Deploy the web application to a remote server **for the first time**.

    The first deployment procedure may differ from subsequent ones,
    since some initialization tasks have to be performed only once.
    Some examples:
    * fake South migrations
    * ..
    """
    env.initial_deploy = True
    deploy()        

def deploy():
    """Deploy the web application to a remote server"""
    require('environment', provided_by=('staging', 'production'))
    ## TODO: early inizialization steps go here
    with settings(warn_only=True):
        webserver_stop()

    update_code()
    update_requirements()
    update_database()
    setup_static_files()

    webserver_start()





from open_municipio.data_import.utils import create_table_schema, get_row_dicts
from open_municipio.data_import.votations.lib import Ballot, Sitting, Vote, BaseVotationReader, VotationDataSource, XMLVotationWriter
from open_municipio.data_import.municipalities.udine import conf

import re, os, csv, datetime, logging, struct
import subprocess



class UdineVotationDataSource(VotationDataSource):
    """
    A set of MDB files generated by the ballot management system in use by
    Udine's municipality.
    """

    # command to export mdb into csv (template)
    export_command = 'mdb-export %(fname)s %(table_name)s'
    logger = logging.getLogger('import')

    # politicians, dictionary
    # components[ID] = {'first_name': 'NAME', 'last_name': 'LAST', 'birth_date': 'YYYYMMDD'}
    components = {}


    def __init__(self, mdb_root_dir):
        self.mdb_root_dir = mdb_root_dir

    def _is_valid_votation_mdb(self, fname):
        """
        Takes a file name ``fname``: if that string is a valid filename for a MDB file 
        containing votation data for a given sitting of the City Council, returns ``True``; 
        otherwise, returns ``False``.
        """
        pattern = re.compile(conf.MDB_SITTING_FNAME_PATTERN)
        if pattern.match(fname):
            return True
        else:
            return False
        
    def _get_sitting_id_from_mdb(self, fname):
        """
        Takes the name of a MDB file containing votation data for a given sitting 
        of the City Council; returns the corresponding sitting ID, as a string.
        """
        pattern = re.compile(conf.MDB_SITTING_FNAME_PATTERN)
        m = pattern.match(fname)
        return m.group('sitting_id')
        

    def _get_sitting_seq_n(self, sitting_id):
        """
        Takes the internal ID for a sitting (as set by the ballot management system)
        and returns the sequential number since the beginning of the current year. 
        """
        # TODO: replace this dummy implementation
        return sitting_id

    def setup(self):
        self.components = self._get_components()

    def _get_components(self):
        """
        Open components file, as defined in configuration,
        and store components details into a structure,
        for later usage
        """
        components = {}
        mdb_component_file = os.path.join(self.mdb_root_dir, conf.MDB_COMPONENT_FNAME)
        self.logger.info("Processing %s" %  mdb_component_file)
        p = subprocess.Popen(self.export_command % {'fname': mdb_component_file , 'table_name': 'Componenti'},
                             shell=True, stdout=subprocess.PIPE)
        csv_reader = csv.DictReader(p.stdout)
        for row_dict in csv_reader:
            self.logger.debug(row_dict)
            components[int(row_dict['IdComp'])] = {
                'nome': row_dict['Nome'],
                'cognome': row_dict['Cognome'],
                'stampato': row_dict['Stampato'],
                'data_nascita': row_dict['DataNascita']
            }

        return components

    def get_sittings(self):
        sittings = []
        # loop over the MDBs containing votation data
        for fname in os.listdir(self.mdb_root_dir):
            # sanity check
            if self._is_valid_votation_mdb(fname):
                mdb_file = os.path.join(self.mdb_root_dir, fname)
                self.logger.info("Processing %s" %  mdb_file)

                # sitting IDs are encoded within filenames
                sitting_id = fname.rstrip('.Mdb')
                sitting = Sitting()
                sitting._id = sitting_id # internal use only
                sitting.seq_n = self._get_sitting_seq_n(sitting_id)
                sitting.mdb_file = mdb_file

                # read MDB file through a CSV stream
                # get Sitting-related info into Sitting instance
                try:
                    p = subprocess.Popen(self.export_command % {'fname': mdb_file , 'table_name': 'CostSed'},
                                         shell=True, stdout=subprocess.PIPE)
                    csv_reader = csv.DictReader(p.stdout)
                    row = csv_reader.next()


                    self.logger.debug(row)

                    # sitting's date, as returned by the DB (i.e. a string)
                    date_string = row['DataSeduta']
                    # convert to a Python ``Date`` object
                    sitting.date =  datetime.datetime.strptime(date_string, '%m/%d/%y %H:%M:%S').date()

                    sitting.call = int(row['Convocazione'])
                    sitting.plenum = int(row['Plenum'])
                    sitting.legis = row['Legis']
                    sittings.append(sitting)
                except StopIteration:
                    self.logger.error("Could not read record in CostSed table of %s Mbd file" % mdb_file)

        return sittings
        
    def get_ballots(self, sitting):
        BALLOT_TYPES = {
                        1: 'Palese Semplice',
                        2: 'Palese Nominale',
                        3: 'Numero Legale',
                        4: 'Segreta',                            
                        }
        OUTCOMES = {
                    0: 'No Esito',
                    1: 'Approvato',
                    2: 'Respinto',
                    3: 'SI Numero Legale',
                    4: 'NO Numero Legale',
                    5: 'Annullata',                                                                
                    }
        # only this kind of ballots are of interest to us
        RELEVANT_BALLOT_TYPES = (1, 2, 4)
        ballots = []

        p = subprocess.Popen(
            self.export_command % {'fname': sitting.mdb_file, 'table_name': 'Votazioni'},
            shell=True, stdout=subprocess.PIPE
        )
        csv_reader = csv.DictReader(p.stdout)
        for row_dict in csv_reader:
            self.logger.debug(row_dict)

            ballot_type_code = int(row_dict['TipoVoto'])
            # filter out irrelevant ballots
            if ballot_type_code in RELEVANT_BALLOT_TYPES:
                ballot = Ballot(
                    sitting = sitting,
                    seq_n = row_dict['NumVoto'],
                    timestamp = datetime.datetime.strptime(row_dict['Data_Ora'], '%m/%d/%y %H:%M:%S'),
                    ballot_type = BALLOT_TYPES[ballot_type_code],
                    short_subj = row_dict['OggettoSint'],
                    subj = row_dict['OggettoEste'],
                    n_presents = row_dict['Presenti'],
                    n_partecipants = row_dict['Votanti'],
                    n_yes = row_dict['Favorevoli'],
                    n_no = row_dict['Contrari'],
                    n_abst = row_dict['Astenuti'],
                    n_legal = row_dict['NumLegale'],
                    outcome = OUTCOMES[int(row_dict['Esito'])],
                )

                ballot.votes = self._get_votes(ballot, row_dict['Dettaglio'])
                ballots.append(ballot)

        return ballots
                     
    def _get_votes(self, ballot, ballot_detail_str):
        VOTE_OUTCOME = {
                      'FAV': 'Favorevole',
                      'CON': 'Contrario',
                      'AST': 'Astenuto', 
                      'VOT': 'Votante (Vot. Segreta)',
                      'NVT': 'Non Votante (4 Tasto)',
                      'PRE': 'Presente(Vot N.L.)',
                      '...': 'Tessera Presente Non Votante',
                      '___': 'Terminale NON INSTALLATO',
                      'ECP': 'Tessera Capovolta',
                      'ETP': 'Errore tipo Tessera',
                      'ELE': 'Errore lettura Tessera',
                      'ELG': 'Errata Legislatura',
                      'EFW': 'Errore Release firmware', 
                      'ENR': 'Errore Non Risponde',
                      'BDO': 'Errore BDO',
                      'EAB': 'Errore Tessera non abilitata',
                      'EPO': 'Errore Posto (posti fissi)',
                      }       
        # interesting outcomes for votes
        # filter out error conditions, etc.    
        RELEVANT_VOTE_CODES = ('FAV', 'CON', 'AST', 'VOT', 'NVT', '...')
        votes = []

        # sanity check: string encoding votes detail must be a multiple of 14
        # (since it's made of 14-bytes records)
        if len(ballot_detail_str) % 14 != 0:
            self.logger.warning("Corrupted table `Votazioni` for sitting #%s" % ballot.sitting._id)
            self.logger.warning("Length: %s" % len(ballot_detail_str))
            ballot_detail_str = ballot_detail_str[0:14*50]

        records = [ballot_detail_str[i:i+14] for i in range(0, len(ballot_detail_str), 14)]
        for record in records:
            self.logger.debug(record)

            ## record format: ``CCCCGGGGTTTXXX``, where:
            ## ``CCCC``: component ID
            ## ``GGGG``: group ID
            ## ``TTT``: card ID
            ## ``XXX``: issued vote
            componentID, groupID, cardID, vote_code = struct.unpack('4s4s3s3s', record)
            if (int(componentID) != 0) and (vote_code in RELEVANT_VOTE_CODES):
                # card missing from voting terminal
                if vote_code == '...' and int(cardID) == 0: continue                 
                vote = Vote(
                            ballot = ballot,
                            cardID = int(cardID), 
                            componentID = int(componentID), 
                            groupID = int(groupID), 
                            choice = VOTE_OUTCOME[vote_code]
                            )

                # retrieve voter's full name
                component = self.components[int(componentID)]
                vote.componentName = component['stampato']

                # append vote to votes
                votes.append(vote)
        return votes


class UdineVotationReader(BaseVotationReader):
    """
    Parse votation-related data from a set of MDB files. 
    """
    def get_data_source(self):
        """
        In this case, the data source is a filesystem directory containing MDB files
        """
        return UdineVotationDataSource(conf.MDB_ROOT_DIR)


class UdineVotationWriter(XMLVotationWriter):
    def get_out_fname(self, sitting):
        return os.path.join(conf.XML_ROOT_DIR, 'sitting_%s.xml' % sitting.date)